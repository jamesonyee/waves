<!DOCTYPE html>

<body>

    <div id="content-wrapper">
        <div id="canvas-container">
            <link rel="stylesheet" href="styles.css" />
            <link rel="stylesheet" href="wave.css" />

            <link rel="stylesheet"
                href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.css" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
            <script>
                hljs.highlightAll();
            </script>

            <button id="fullscreen-btn">Fullscreen</button>
            <canvas id="glCanvas"></canvas>

            <script src="js/waves.js"></script>
            <script src="js/gl-matrix-min.js"></script>

            <div style="position: absolute; top: 10px; left: 10px; color: white">
                <!-- Lighting Section -->
                <details>
                    <summary>Lighting</summary>
                    <label for="daylight">Daylight:</label>
                    <input type="range" id="daylight" min="-500" max="500" step="1" value="0" />
                    <br />
                    <label for="noiseAmp">Noise Amplitude:</label>
                    <input type="range" id="noiseAmp" min="0" max="1" step="0.01" value="0.1" />
                    <span id="noiseAmpValue">0</span><br />

                    <label for="noiseFreq">Noise Frequency:</label>
                    <input type="range" id="noiseFreq" min="0" max="0.15" step="0.001" value="0.1" />
                    <span id="noiseFreqValue">1</span>
                </details>

                <!-- Time Scale Section -->
                <details>
                    <summary>Wave speed</summary>
                    <label for="timeScale">Time Scale:</label>
                    <input type="range" id="timeScale" min="0" max="3" step="0.01" value="1" />
                    <span id="timeScaleValue">1</span>
                </details>

                <!-- Wave 1 Section -->
                <details>
                    <summary>Wave 1</summary>
                    <label for="amp0">Amplitude:</label>
                    <input type="range" id="amp0" min="0" max="1.0" step="0.01" value="0.75" />
                    <span id="amp0Value">0.4</span><br />

                    <label for="propAng0">Wave Angle:</label>
                    <input type="range" id="propAng0" min="-1" max="1" step="0.01" value="0.5" />
                    <span id="propAng0Value">0</span><br />

                    <label for="density0">Density:</label>
                    <input type="range" id="density0" min="0" max="1" step="0.01" value="0.25" />
                    <span id="density0Value">1</span>
                </details>

                <!-- Wave 2 Section -->
                <details>
                    <summary>Wave 2</summary>
                    <label for="amp1">Amplitude:</label>
                    <input type="range" id="amp1" min="0" max="1.0" step="0.01" value="0" />
                    <span id="amp1Value">0.4</span><br />

                    <label for="propAng1">Wave Angle:</label>
                    <input type="range" id="propAng1" min="-1" max="1" step="0.01" value="0" />
                    <span id="propAng1Value">0</span><br />

                    <label for="density1">Density:</label>
                    <input type="range" id="density1" min="0" max="1" step="0.01" value="0" />
                    <span id="density1Value">1</span>
                </details>
            </div>
        </div>
        <div id="writeup">
            <p class="github">
                <a href="https://github.com/jamesonyee/jamesonyee.github.io/tree/main/shaders">
                    <i class="fa fa-github-square" style="font-size: 48px"> </i>
                </a>
            </p>
            <h1>Overview</h1>
            <p>
                This WebGL project features a dynamic wave animation enhanced by a
                fragment shader to give the water a more realistic interation with the
                lighting. The wave simulation is based on the equation for trochoidal
                motion, commonly known as Gerstner waves. This approach, rooted in
                fluid dynamics, is derived from the Euler equations and accurately
                models the periodic motion of fluid particles in a wave.
            </p>

            <h3>Features</h3>
            <p>
                This program provides an intuitive interface with sliders that allow
                users to explore and modify each part of the Gerstner wave equation as
                well as and lighting effects interactively.
                <br />
                <br />
                Real-Time Feedback: Any changes made to sliders are instantly rendered
                on the wave surface, providing immediate visual feedback that
                demonstrates the interaction diferrent aspects of the program.
            </p>

            <h2>Gerstner Wave equation</h2>
            <img src="https://upload.wikimedia.org/wikipedia/commons/1/12/Forces_in_Trochoidal_wave.gif" />

            <p>
                The Gerstner wave equations model the displacement of points on the
                surface of water in three dimensions. These equations take into
                account horizontal and vertical motion using sinusoidal functions
                based on amplitude, wave density, and propagation angle:
            </p>

            <ul>
                <li>
                    <b>Horizontal Motion (x'): </b> Adjusts the original x-coordinate by
                    subtracting a summation of terms involving amplitude (<code>A<sub>m</sub></code>), wave propagation
                    angle
                    (<code>&gamma;<sub>m</sub></code>), and the sine of wave phase (<code>&theta;<sub>m</sub></code>).
                </li>
                <li>
                    <b>Vertical Motion (y'): </b> Adds vertical displacement using a
                    cosine function of the wave phase (<code>&theta;<sub>m</sub></code>).
                </li>
                <li>
                    <b>Horizontal Motion (z'): </b> Similar to x', adjusts the
                    z-coordinate based on sine terms.
                </li>
            </ul>

            <p>
                The wave phase (<code>&theta;<sub>m</sub></code>) depends on wave density (<code>k<sub>m</sub></code>),
                the
                position of the point, and time (<code>t</code>), resulting in
                a periodic and realistic simulation of wave motion. This approach not
                only simulates the fluid surface but also reflects interactions with
                lighting for an enhanced visual effect.
            </p>

            <details>
                <summary>View PDF</summary>
                <embed src="src/GerstnerEquation-MJB.pdf" width="100%" height="850" type="application/pdf" />
            </details>
            <a href="https://web.engr.oregonstate.edu/~mjb/cs557/Handouts/WaveMotion.1pp.pdf">
                <p class="caption">
                    Animating Wave Motion using Gerstner Waves. Mike Bailey, Oregon
                    State University, CS557 -- Computer Graphics Shaders, December 2023.
                </p>
            </a>

            <h3>Vertex Shader implementation</h3>

            <pre><code class="hljs language-c">
// Wave 1 - Vertex Displacement 
float freq0 = sqrt(g * uDensity0);

float thetam = uDensity0 * cos(uPropAng0) * aVertexPosition.x +
               uDensity0 * sin(uPropAng0) * aVertexPosition.z -
               freq0 * Timer * uTimeScale;

newx -= uAmp0 * cos(uPropAng0) * sin(thetam);
newy += uAmp0 * cos(thetam);
newz -= uAmp0 * sin(uPropAng0) * sin(thetam);
        </code></pre>
            <p>
                This is the displacement portion of the vertex shader which reads in
                slider vaules (variables that have a "u" prefix) into the gersnter
                equation explained above.
            </p>

            <pre><code class="hljs language-javascript">
float dthetamda = uDensity0 * cos(uPropAng0);
float dthetamdb = uDensity0 * sin(uPropAng0);
dxda -= uAmp0 * cos(uPropAng0) * cos(thetam) * dthetamda;
dyda -= uAmp0 * sin(thetam) * dthetamda;
dzda -= uAmp0 * sin(uPropAng0) * cos(thetam) * dthetamda;
dxdb -= uAmp0 * cos(uPropAng0) * cos(thetam) * dthetamdb;
dydb -= uAmp0 * sin(thetam) * dthetamdb;
dzdb -= uAmp0 * sin(uPropAng0) * cos(thetam) * dthetamdb;
        </code></pre>
            <p>
                This math is used to calculate the surface normal of the wave in its
                current form to be sent to the fragment shader for lighting. In the 2D
                wikipedia illustration this
            </p>
            <h3>Fragment Shader implementation</h3>
            <pre><code class="hljs language-javascript">
void main(void) {
  vec3 myColor = vec3(0.2, 0.2, .8); // Blue water color
  vec3 specularColor = vec3(1.0, 1.0, 1.0); // White reflection color
  
  vec4 nvx = texture( Noise3, uNoiseFreq*vMC );
  float angx = nvx.r + nvx.g + nvx.b + nvx.a  -  2.;	// -1. to +1.
  angx *= uNoiseAmp;

  vec4 nvy = texture( Noise3, uNoiseFreq*vec3(vMC.xy,vMC.z+0.5) );
  float angy = nvy.r + nvy.g + nvy.b + nvy.a  -  2.;	// -1. to +1.
  angy *= uNoiseAmp;

  vec3 Normal = normalize(vN);
  Normal = RotateNormal(angx, angy, Normal);

  vec3 Light = normalize(vL);
  vec3 Eye = normalize(vE);

  float uKa = .6;
  float uKs = .4;
  float uKd = .3;
  float uShininess = 100.; 

  vec3 ambient = uKa * myColor;
  
  float dd = max(dot(normalize(vN), Light), 0.0);
  vec3 diffuse = uKd * dd * myColor;

  float ss = 0.;
  if ( dot(Normal, Light) > 0. ){
    vec3 ref = normalize( reflect( -Light, Normal) );
    ss = pow( max( dot(Eye,ref),0. ), uShininess );
  }

  vec3 specular = uKs * ss * specularColor.rgb;
  fragColor = vec4( ambient + diffuse + specular, 1. );
}
        </code></pre>

            <h2>Lighting Interaction</h2>
            <ol>
                <li>
                    Daylight Adjustment:
                    <ul>
                        <li>
                            enables users to manipulate the scene's light level in a way
                            that simulates the path of the sun. This feature highlights the
                            interplay between light and water, showcasing how light
                            reflections and shading adapt to the dynamic wave patterns.
                        </li>
                    </ul>
                </li>
            </ol>

            <h2>Wave Customization</h2>
            <ol>
                <li>
                    Water Settings:
                    <ul>
                        <li>
                            Noise Amplitude and Noise Frequency: These sliders provide
                            additional customization for adding subtle irregularities or
                            randomness to the water, enhancing realism.
                        </li>
                    </ul>
                </li>

                <li>Wave Speed</li>
                <ul>
                    <li>
                        Allows users to adjust the time scale with a slider, directly
                        influencing the animation's speed.
                    </li>
                </ul>

                <li>Individual Wave Settings (Wave 1 & Wave 2)</li>
                <ul>
                    <li>
                        Amplitude: Enable users to control the height of the waves,
                        demonstrating how amplitude changes impact the overall water
                        surface appearance.
                    </li>
                    <li>
                        Wave Angle: Adjusting this sliders manipulates the direction of
                        wave propagation, allowing users to observe the interaction
                        between multiple waves from different angles.
                    </li>
                    <li>
                        Density: The density sliders help users fine-tune the wave's
                        appearance, possibly affecting the frequency or compactness of the
                        wave pattern.
                    </li>
                </ul>
            </ol>

            <h1>Key Components</h1>
            <h2>1. The grid</h2>

            <img src="https://developer.download.nvidia.com/books/gpugems/fig01-05.jpg" />

            <a
                href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models">
                <p class="caption">Nvidia GPU Gems: Figure 1-5 Gerstner Waves</p>
            </a>

            <h3>Why a grid?</h3>

            <p>
                A quad (simple plane) consists of only four vertices, which limits its
                potential for complex transformations in the vertex shader. By
                converting it into a grid with many vertices, shaders can manipulate
                the surface in finer detail. This is essential for effects like wave
                simulations, lighting interactions, and deformation.
            </p>

            <p>This function generates a subdivided grid, including:</p>

            <ul>
                <li>Vertices: Positions of each point on the grid.</li>
                <li>Normals: Upward-facing normals for basic lighting.</li>
                <li>Connectivity between vertices to define triangles.</li>
            </ul>

            <pre><code class="hljs language-javascript">
function createGridWithNormals(size, divisions) {
  const halfSize = size / 2;
  const step = size / divisions;
  const vertices = [];
  const normals = [];
  const indices = [];

  for (let j = 0; j <= divisions; j++) {
    for (let i = 0; i <= divisions; i++) {
      const x = -halfSize + i * step;
      const z = -halfSize + j * step;
      vertices.push(x, 0, z);
      normals.push(0, 1, 0);
    }
  }

  for (let j = 0; j < divisions; j++) {
    for (let i = 0; i < divisions; i++) {
      const topLeft = j * (divisions + 1) + i;
      const topRight = topLeft + 1;
      const bottomLeft = topLeft + (divisions + 1);
      const bottomRight = bottomLeft + 1;
      indices.push(topLeft, bottomLeft, topRight);
      indices.push(topRight, bottomLeft, bottomRight);
    }
  }

  return {
    vertices: new Float32Array(vertices),
    normals: new Float32Array(normals),
    indices: new Uint32Array(indices),
  };
}
        </code></pre>
            <img src="src/quadxz.jpg" />

            <h3>Key Advantages</h3>
            <ol>
                <li>
                    Better Shader Performance: A dense grid allows vertex shaders to
                    calculate individual transformations (e.g., simulating waves).
                </li>
                <li>
                    Improved Lighting: With more vertices, normals can be computed
                    accurately, leading to smoother lighting effects.
                </li>
                <li>
                    High Detail: Visual effects like water ripples or terrain
                    deformation look more realistic on a subdivided grid.
                </li>
            </ol>

            <h2>3. Render loop</h2>

            <pre><code class="hljs language-javascript">
function render() {
    resizeCanvas();
    
    const currentTime = Date.now();
    const elapsedTime = (currentTime - startTime) / 1000; // in seconds

    gl.uniform1f(timerLocation, elapsedTime);

    gl.uniform1f(timeScaleLocation, parseFloat(timeScaleSlider.value));

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.drawElements(
      gl.TRIANGLES,
      gridVertices.indices.length,
      gl.UNSIGNED_INT,
      0
    );

    requestAnimationFrame(render);
}
        </code></pre>
            <p>
                This function powers the scene's animation by calculating the elapsed
                time from the current timestamp and passing it to the vertex shader to
                determine vertex displacement. It also incorporates user input from a
                slider (ranging from 0 to 3) to adjust the time scale multiplier,
                enabling users to control the wave animation speed. The function is
                called to redraw the scene every frame, typically at the refresh rate
                of the user's monitor (usually 60 frames per second).
            </p>
        </div>
    </div>
</body>

</html>